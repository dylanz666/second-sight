# Second Sight - 远程桌面系统

一个基于FastAPI和WebSocket的实时Windows桌面截图和监控工具，支持多显示器独立显示。

## 功能特性

### 🖥️ 多显示器支持
- **自动检测**：自动识别系统中的所有显示器
- **独立显示**：每个显示器独立显示，不拼接
- **主显示器标识**：绿色边框标识主显示器
- **独立刷新**：每个显示器可单独刷新
- **全屏查看**：点击图片或全屏按钮查看

### 📊 实时监控
- **系统资源监控**：实时显示内存、CPU使用率
- **网络状态监控**：检测网络连接质量和延迟
- **WebSocket实时通信**：实时更新状态信息
- **自动刷新**：可设置自动刷新间隔

### 🔧 调试功能
- **显示器配置查看**：显示详细的显示器配置信息
- **强制重新检测**：强制重新检测显示器配置
- **单个显示器调试**：单独测试每个显示器的截图功能
- **系统信息查看**：查看详细的系统资源使用情况

### 📷 截图收起功能
- **选择性隐藏**：用户可以独立收起/展开每个显示器
- **自动收起**：检测到多个显示器时自动收起非主显示器，只显示主显示器
- **性能优化**：收起的显示器不会进行截图获取，节省系统资源
- **前后端同步**：前端状态与后端状态实时同步，确保真正的资源节省
- **一键重置**：提供"重置收起"按钮快速恢复所有显示器
- **智能状态管理**：正确区分"所有显示器都被收起"和"没有显示器数据"的状态

### ⚡ 性能优化功能
- **智能缓存**：内存缓存机制，避免重复处理相同截图
- **质量调节**：可调节图像质量、尺寸和压缩级别
- **格式选择**：支持PNG和JPEG格式，平衡质量和文件大小
- **缓存管理**：实时查看缓存统计，手动清除缓存
- **传输优化**：优化的图像传输算法，减少网络带宽占用

## 安装依赖

```bash
pip install -r requirements.txt
```

### 依赖包说明
- `fastapi`: Web框架
- `uvicorn`: ASGI服务器
- `pillow`: 图像处理
- `pywin32`: Windows API接口
- `psutil`: 系统资源监控

## 运行方式

### 方式1：直接打开HTML文件
1. 启动服务器：
   ```bash
   python server.py
   ```
2. 双击打开 `index.html`
3. 页面会自动连接到 `localhost:8000`

### 方式2：通过HTTP访问
1. 启动服务器：
   ```bash
   python server.py
   ```
2. 浏览器访问：`http://localhost:8000`

## 最近修复

### 全屏状态保护修复 (2024-12-19)
**问题描述**：当截图自动更新时，如果用户正在全屏查看某个显示器，会自动退出全屏模式，影响用户体验。

**根本原因**：
- 截图更新时会重新设置图片的 `src` 属性
- 浏览器认为图片元素发生了变化，自动退出全屏状态
- 自动刷新功能每0.8秒更新一次，频繁触发全屏退出
- `/screenshots/all` 接口的滞后性导致DOM重建时破坏全屏状态

**修复方案（第四版 - 最终版）**：
1. **DOM结构保护**：检测全屏状态，避免重建处于全屏的DOM元素
2. **智能更新策略**：当有显示器处于全屏时，采用保守更新而非完全重建
3. **元素级保护**：在更新现有元素时检查全屏状态，跳过全屏元素的更新
4. **状态感知更新**：根据全屏状态动态选择更新策略

**技术实现**：
- 修改 `displayMultiMonitors()` 函数，添加全屏状态检测
- 新增 `createMonitorElement()` 函数用于创建新显示器元素
- 新增 `updateExistingMonitorElement()` 函数用于安全更新现有元素
- 在更新逻辑中添加 `document.fullscreenElement` 检查
- 全屏时跳过 `img.src` 更新，保持原有图片不变

**修复效果**：
- ✅ 全屏状态下不会自动退出全屏
- ✅ 保持截图实时更新功能（非全屏显示器）
- ✅ 解决 `/screenshots/all` 接口滞后导致的退出问题
- ✅ 提升用户体验，避免意外退出全屏
- ✅ 兼容所有主流浏览器
- ✅ 无需暂停自动刷新，保持实时性

### 截图收起功能状态管理修复 (2024-12-19)
**问题描述**：当所有显示器都被收起时，前端错误显示"所有显示器都已收起"的占位符，即使部分显示器只是被收起而不是真正消失。

**根本原因**：
- `/screenshots/all` 接口只返回未收起的显示器数据
- 前端错误地将返回的显示器数量作为总显示器数量
- 导致 `areAllMonitorsCollapsed()` 函数无法正确判断状态

**修复方案**：
1. **后端修改**：`/screenshots/all` 接口新增 `total_monitor_count` 字段，返回系统中的总显示器数量
2. **前端修改**：使用API返回的 `total_monitor_count` 而不是当前活跃显示器数量来判断状态
3. **逻辑优化**：正确处理空数组响应，区分"全部收起"和"无数据"状态

**修复效果**：
- ✅ 正确识别所有显示器都被收起的状态
- ✅ 避免误判导致的UI显示错误
- ✅ 保持性能优化效果（收起的显示器不获取截图）

## API接口

### 基础接口
- `GET /` - 主页
- `GET /status` - 服务器状态
- `GET /screenshot` - 获取桌面截图

### 多显示器接口
- `GET /screenshots/all` - 获取所有显示器截图（跳过被收起的显示器，返回 `total_monitor_count` 字段）
- `GET /screenshot/monitor/{monitor_index}` - 获取指定显示器截图（检查收起状态）
- `GET /monitors/config` - 获取显示器配置信息
- `POST /collapsed-monitors` - 更新被收起的显示器状态
- `GET /collapsed-monitors` - 获取当前被收起的显示器状态

### 监控接口
- `GET /system-info` - 获取系统资源信息
- `GET /test-network` - 测试网络连接
- `GET /force-redetect` - 强制重新检测显示器

### 调试接口
- `GET /debug/monitor/{monitor_index}` - 调试指定显示器
- `GET /screenshot-info` - 获取截图详细信息

### 性能优化接口
- `GET /quality-settings` - 获取当前质量设置
- `POST /quality-settings` - 更新质量设置
- `GET /cache-stats` - 获取缓存统计信息
- `POST /clear-cache` - 清除图像缓存

### WebSocket
- `WS /ws` - 实时状态推送

## 系统监控功能

### 内存监控
- 实时内存使用率
- 总内存、已用内存、可用内存
- 自动更新（每5秒）

### CPU监控
- 实时CPU使用率
- CPU核心数、频率
- 自动更新（每5秒）

### 磁盘监控
- 磁盘使用率
- 总容量、已用空间、可用空间
- 自动更新（每5秒）

### 网络监控
- 网络连接状态
- 网络延迟
- 自动更新（每30秒）

## 截图收起功能详解

### 功能概述
截图收起功能允许用户隐藏特定显示器的实时截图，以提高系统响应速度和节省资源。该功能同时在前端和后端实现，确保真正的性能优化。

### 使用方法
1. **收起显示器**: 点击显示器控制栏中的"📷 收起"按钮
2. **展开显示器**: 点击显示器控制栏中的"👁️ 展开"按钮
3. **重置所有**: 点击页面顶部的"🔄 重置收起"按钮
4. **自动收起**: 当检测到多个显示器时，系统会自动收起非主显示器，只显示主显示器

### 技术实现

#### 前端实现
- **状态管理**: 使用 `Set` 数据结构 (`collapsedMonitors`) 高效跟踪收起状态
- **UI更新**: 收起状态下显示占位图片，隐藏实际截图
- **状态同步**: 每次状态变更都会立即同步到后端
- **安全检查**: 收起状态下禁用刷新和全屏功能

#### 后端实现
- **状态跟踪**: 使用全局 `set()` 数据结构 (`collapsed_monitors`) 跟踪收起状态
- **截图过滤**: `/screenshots/all` 接口跳过被收起显示器的截图获取
- **单显示器检查**: `/screenshot/monitor/{index}` 接口检查显示器是否被收起
- **状态同步**: 提供 RESTful API 进行前后端状态同步

#### 性能优化
- **前端优化**: 收起状态下跳过截图显示，减少 DOM 操作
- **后端优化**: 收起状态下跳过截图获取，减少 CPU 和内存使用
- **数据传输**: 使用占位图片替代实际截图，减少网络传输

### 自动收起功能
- **智能检测**: 系统首次检测到多个显示器时，自动收起非主显示器
- **性能优先**: 默认只显示主显示器，减少资源消耗
- **用户控制**: 用户可随时展开其他显示器或重置收起状态
- **状态保持**: 自动收起状态会保持到用户手动重置为止

### 注意事项
- 收起状态仅在当前会话中保持，页面刷新后会重置
- 后端状态会在服务器重启后重置
- 建议在不需要查看特定显示器时使用收起功能以提升性能
- 自动收起功能仅在首次检测到多个显示器时执行，避免重复收起

## 性能优化功能详解

### 功能概述
性能优化功能通过多种技术手段提升截图传输速度和系统响应性能，包括智能缓存、质量调节、格式优化等。

### 智能缓存机制
- **内存缓存**：将处理过的图像缓存到内存中，避免重复处理
- **缓存键生成**：基于显示器索引和质量设置生成唯一缓存键
- **自动清理**：缓存项有过期时间，自动清理过期和超量的项目
- **缓存统计**：实时显示缓存命中率和使用情况

### 质量设置选项
- **图像尺寸**：可调节单显示器和桌面截图的最大尺寸
- **图像格式**：支持PNG（高质量）和JPEG（小文件）格式
- **质量参数**：PNG质量（1-100）、JPEG质量（1-100）、PNG压缩级别（0-9）
- **优化选项**：启用PNG优化以减小文件大小

### 使用方法
1. **质量设置**：点击"⚙️ 质量设置"按钮打开设置面板
2. **缓存管理**：点击"💾 缓存管理"按钮查看缓存统计
3. **实时调节**：在设置面板中调节各项参数，实时预览效果
4. **保存设置**：点击"保存设置"应用新的质量配置

### 性能提升效果
- **传输速度**：缓存命中时可提升50-80%的响应速度
- **文件大小**：JPEG格式可比PNG减少60-80%的文件大小
- **网络带宽**：优化的压缩算法可减少30-50%的带宽占用
- **系统资源**：避免重复处理可减少CPU和内存使用

### 最佳实践
- **网络环境差**：使用JPEG格式，降低质量到60-80
- **网络环境好**：使用PNG格式，保持高质量
- **多显示器**：适当降低图像尺寸以提升性能
- **频繁刷新**：保持缓存开启以获得最佳性能

## 技术架构

### 后端 (Python)
- **FastAPI**: 现代、快速的Web框架
- **WebSocket**: 实时双向通信
- **win32api**: Windows系统API调用
- **PIL**: 图像处理和截图
- **psutil**: 系统资源监控

### 前端 (HTML/CSS/JavaScript)
- **响应式设计**: 适配不同屏幕尺寸
- **实时更新**: WebSocket实时通信
- **多显示器布局**: 网格布局显示多个显示器
- **交互式控制**: 丰富的用户交互功能

## 故障排除

### 常见问题

1. **显示器检测不准确**
   - 点击"强制重新检测"按钮
   - 检查Windows显示设置
   - 查看系统日志获取详细信息

2. **截图显示不全**
   - 运行诊断脚本：`python deep_diagnosis.py`
   - 检查显示器配置信息
   - 确认显示器排列设置

3. **系统监控数据异常**
   - 检查psutil是否正确安装
   - 确认有足够的系统权限
   - 查看服务器日志

### 调试工具

- **深度诊断脚本**: `python deep_diagnosis.py`
- **显示器测试脚本**: `python test_monitor_capture.py`
- **前端调试按钮**: 使用界面上的调试功能

## 开发说明

### 项目结构
```
second-sight/
├── server.py              # 主服务器文件
├── index.html             # 前端界面
├── requirements.txt       # Python依赖
├── README.md             # 项目说明
├── deep_diagnosis.py     # 深度诊断脚本
├── test_monitor_capture.py # 显示器测试脚本
└── start_server.bat      # 启动脚本
```

### 扩展功能
- 支持更多显示器配置
- 添加更多系统监控指标
- 实现远程控制功能
- 添加用户认证和权限控制

## 许可证

MIT License 



TBD
1. 文件管理“已选择”按钮文本调整-->Done
2. 文件管理要展示文件夹？-->不-->Done
3. 弹窗要展示文件？-->不-->Done
4. 上一级目录逻辑要优化-->Done
5. 点击跳转根目录按钮，loading?或者目录元素要马上变或者 loading-->Done
6. 每个文件夹下的数量 count 指示调整-->Done
7. 优化上级目录、根目录入口与逻辑-->Done
8. 新增默认入口与逻辑-->Done
9. 优化刷新逻辑-->Done
10. 文件选中后逻辑优化-->Done
11. 文件选中后再次点击要改为未选中-->Done
12. 增加文件夹删除入口与功能-->Done
13. 增加新增文件夹入口与功能-->Done
14. 修复新增文件夹一直放在 Downloads 文件夹下的问题-->Done
15. 文件路径要改为可复制-->Done
16. 修复上级目录功能(针对无权访问的目录)-->Done
17. 当有些盘超时，只返回未超时的那些盘符--Done
18. 移除前端调试日志；-->Done
19. 新建文件夹按钮位置调整；-->Done
20. 系统盘符的“进入”功能；--Done
21. 修复在我的电脑下点击刷新按钮会在文件夹列表中多出“我的电脑”一项的问题-->Done
22. 开始自动刷新+停止自动刷新，两个按钮合二为一-->Done
23. 修复 bug: 收起截图后还会刷新截图；-->Done
24. 图片加载太久，要优化，如压缩；-->Done
25. 全屏时由于截图更新会自动退出全屏；-->Done
26. 修改"质量设置"按钮的样式；-->Done
27. 修复收起功能：收起时保留显示器元素，确保副显示屏可见；-->Done

26. js 文件太大，需要提取公共方法、分割为几个 js 文件；-->Doing
27. 键鼠操作-->优先级高
28. 部署-->优先级低
29. 录制屏幕与下载-->优先级低

# Server Controller GUI (.exe via Tkinter + PyInstaller)

功能：启动 server、停止 server、重启 server、检测 server、最小化程序窗口。

## 1) 运行（开发态）

- 安装依赖：
  ```bash
  pip install -r requirements.txt
  ```
- 启动 GUI：
  ```bash
  python server_gui/main.py
  ```
- 配置：编辑 `server_gui/server_config.json`
  - `command`: 启动服务的命令（字符串），例如 `"python server.py"` 或 `"uvicorn app:app --host 0.0.0.0 --port 8000"`
  - `working_directory`: 工作目录（留空则使用程序所在目录）
  - `port`: 端口（用于端口检测）
  - `healthcheck_url`: 健康检查 URL（优先使用）
  - `pid_file`: PID 文件路径（留空自动放程序目录）
  - `log_file`: 日志文件路径（留空自动放程序目录）
  - `graceful_stop_seconds`: 优雅停止的等待秒数

## 2) 打包为 Windows 可执行文件 (.exe)

在 Windows 环境下执行（推荐在 Windows 上打包）：

```bash
pyinstaller --noconsole --onefile --name ServerController \
  --icon NONE server_gui/main.py
```

- 生成的可执行文件位于 `dist/ServerController.exe`
- 若需要图标，请替换 `--icon NONE` 为你的 `icon.ico` 路径
- 打包后把 `server_config.json` 放在与 `ServerController.exe` 同一目录下，便于修改配置

> 注：在 Linux 上生成 Windows .exe 通常需要 Wine 等额外工具，不建议跨平台打包。

## 3) 常见问题

- 启动失败：请确认 `command` 可在 `working_directory` 正常执行；必要时写全路径或使用虚拟环境 Python 的完整路径。
- 停止失败：如服务会拉起子进程，建议服务自身支持优雅退出；本工具在 Windows 下会 fallback 使用 `taskkill /T /F`，在类 Unix 下会尝试 `SIGTERM` 并在必要时 `SIGKILL`。
- 检测失败：优先配置 `healthcheck_url`；否则使用端口检测。
